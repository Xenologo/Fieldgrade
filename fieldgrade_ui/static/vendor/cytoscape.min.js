/*! cytoscape (LOCAL VENDOR SHIM)
 *
 * Purpose: remove CDN dependency for offline Fieldgrade deployments.
 *
 * This is NOT the full Cytoscape.js library. It implements a small, compatible subset
 * of the Cytoscape API used by fieldgrade_ui/static/app.js:
 *   - cytoscape({ container, elements, style, layout })
 *   - cy.add([...])
 *   - cy.elements().remove()
 *   - cy.layout(opts).run()
 *   - cy.fit(cy.elements(), padding)
 *   - cy.on('select', 'node'|'edge', handler)
 *   - cy.on('unselect', handler)
 *   - cy.$(':selected')
 *
 * If you need full Cytoscape functionality, replace this file with the official
 * Cytoscape.js distribution (MIT licensed) and keep the index.html reference.
 */
(function () {
  'use strict';

  function _el(tag) {
    return document.createElementNS('http://www.w3.org/2000/svg', tag);
  }

  function _clearNode(node) {
    while (node && node.firstChild) node.removeChild(node.firstChild);
  }

  function _toNum(x, fallback) {
    var n = Number(x);
    return Number.isFinite(n) ? n : fallback;
  }

  function _parseRootSelector(sel) {
    if (!sel) return null;
    if (typeof sel !== 'string') return null;
    sel = sel.trim();
    if (sel.startsWith('#')) return sel.slice(1);
    return sel;
  }

  function _bbox(points) {
    var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (var i = 0; i < points.length; i++) {
      var p = points[i];
      if (!p) continue;
      if (p.x < minX) minX = p.x;
      if (p.y < minY) minY = p.y;
      if (p.x > maxX) maxX = p.x;
      if (p.y > maxY) maxY = p.y;
    }
    if (!Number.isFinite(minX)) {
      minX = 0; minY = 0; maxX = 100; maxY = 100;
    }
    return { minX: minX, minY: minY, maxX: maxX, maxY: maxY };
  }

  function _Collection(cy, elems) {
    this._cy = cy;
    this._elems = Array.isArray(elems) ? elems : [];
    this.length = this._elems.length;
  }
  _Collection.prototype.remove = function () {
    // The UI only calls cy.elements().remove(), so clear everything.
    this._cy._clearAll();
    return this;
  };

  function _Target(type, dataObj, cy) {
    this._type = type;
    this._data = dataObj || {};
    this._cy = cy;
  }
  _Target.prototype.data = function () {
    return this._data;
  };
  _Target.prototype.isNode = function () { return this._type === 'node'; };
  _Target.prototype.isEdge = function () { return this._type === 'edge'; };

  function _Cytoscape(opts) {
    opts = opts || {};
    if (!opts.container) throw new Error('cytoscape: container is required');

    this._container = opts.container;
    this._nodes = [];  // { data, _pos }
    this._edges = [];  // { data }
    this._selectedNodeId = null;
    this._selectedEdgeId = null;
    this._handlers = { select: [], unselect: [] };

    // Create SVG surface
    _clearNode(this._container);
    var svg = _el('svg');
    svg.setAttribute('width', '100%');
    svg.setAttribute('height', '100%');
    svg.style.display = 'block';
    svg.style.background = 'transparent';

    var gEdges = _el('g');
    var gNodes = _el('g');
    svg.appendChild(gEdges);
    svg.appendChild(gNodes);

    this._svg = svg;
    this._gEdges = gEdges;
    this._gNodes = gNodes;

    // Background click => unselect
    svg.addEventListener('click', (function (self) {
      return function (evt) {
        if (evt.target === svg) {
          self._unselectAll();
        }
      };
    })(this));

    this._container.appendChild(svg);

    // Initial elements/layout
    if (opts.elements) {
      this.add(opts.elements);
    }
    if (opts.layout && typeof opts.layout === 'object') {
      this.layout(opts.layout).run();
    } else {
      this.layout({ name: 'grid' }).run();
    }
  }

  _Cytoscape.prototype._clearAll = function () {
    this._nodes = [];
    this._edges = [];
    this._selectedNodeId = null;
    this._selectedEdgeId = null;
    _clearNode(this._gEdges);
    _clearNode(this._gNodes);
    this._emit('unselect', null);
  };

  _Cytoscape.prototype.elements = function () {
    var all = this._nodes.concat(this._edges);
    return new _Collection(this, all);
  };

  _Cytoscape.prototype.add = function (els) {
    var list = els;
    if (!Array.isArray(list)) {
      // Support { nodes: [...], edges: [...] }
      if (els && typeof els === 'object') {
        list = [];
        if (Array.isArray(els.nodes)) list = list.concat(els.nodes);
        if (Array.isArray(els.edges)) list = list.concat(els.edges);
      } else {
        list = [];
      }
    }

    for (var i = 0; i < list.length; i++) {
      var item = list[i];
      if (!item || typeof item !== 'object') continue;
      var data = item.data || {};
      if (data.source && data.target) {
        // edge
        if (!data.id) data.id = 'e_' + data.source + '_' + data.target + '_' + i;
        this._edges.push({ data: data });
      } else {
        // node
        if (!data.id) continue;
        this._nodes.push({ data: data, _pos: { x: 0, y: 0 } });
      }
    }

    return this;
  };

  _Cytoscape.prototype.layout = function (opts) {
    var self = this;
    opts = opts || {};
    return {
      run: function () {
        self._applyLayout(opts);
        self._render();
      }
    };
  };

  _Cytoscape.prototype.fit = function (_els, padding) {
    var pad = _toNum(padding, 30);
    var pts = [];
    for (var i = 0; i < this._nodes.length; i++) {
      pts.push(this._nodes[i]._pos);
    }
    var b = _bbox(pts);
    var w = Math.max(1, b.maxX - b.minX);
    var h = Math.max(1, b.maxY - b.minY);
    this._svg.setAttribute('viewBox', (b.minX - pad) + ' ' + (b.minY - pad) + ' ' + (w + 2 * pad) + ' ' + (h + 2 * pad));
  };

  _Cytoscape.prototype.$ = function (selector) {
    if (selector === ':selected') {
      var sel = [];
      if (this._selectedNodeId) sel.push(this._selectedNodeId);
      if (this._selectedEdgeId) sel.push(this._selectedEdgeId);
      return { length: sel.length };
    }
    return { length: 0 };
  };

  _Cytoscape.prototype.on = function (eventName, selector, handler) {
    if (typeof selector === 'function') {
      handler = selector;
      selector = null;
    }
    if (typeof handler !== 'function') return this;

    if (eventName === 'select') {
      this._handlers.select.push({ selector: selector || null, fn: handler });
    } else if (eventName === 'unselect') {
      this._handlers.unselect.push({ fn: handler });
    }
    return this;
  };

  _Cytoscape.prototype._emit = function (eventName, target) {
    var i, h;
    if (eventName === 'select') {
      for (i = 0; i < this._handlers.select.length; i++) {
        h = this._handlers.select[i];
        if (!h) continue;
        if (h.selector === 'node' && target && target.isNode && !target.isNode()) continue;
        if (h.selector === 'edge' && target && target.isEdge && !target.isEdge()) continue;
        try { h.fn({ target: target }); } catch (e) { /* ignore */ }
      }
    } else if (eventName === 'unselect') {
      for (i = 0; i < this._handlers.unselect.length; i++) {
        h = this._handlers.unselect[i];
        if (!h) continue;
        try { h.fn({ target: target }); } catch (e2) { /* ignore */ }
      }
    }
  };

  _Cytoscape.prototype._unselectAll = function () {
    if (this._selectedNodeId || this._selectedEdgeId) {
      this._selectedNodeId = null;
      this._selectedEdgeId = null;
      this._render();
      this._emit('unselect', null);
    }
  };

  _Cytoscape.prototype._applyLayout = function (opts) {
    var name = String(opts.name || 'grid').toLowerCase();
    if (name === 'breadthfirst') {
      this._layoutBreadthFirst(opts);
    } else {
      this._layoutGrid(opts);
    }
  };

  _Cytoscape.prototype._layoutGrid = function (_opts) {
    var n = this._nodes.length;
    var cols = Math.max(1, Math.ceil(Math.sqrt(n)));
    var spacing = 120;
    for (var i = 0; i < n; i++) {
      var r = Math.floor(i / cols);
      var c = i % cols;
      this._nodes[i]._pos = { x: c * spacing, y: r * spacing };
    }
  };

  _Cytoscape.prototype._layoutBreadthFirst = function (opts) {
    var rootId = _parseRootSelector(opts.roots);
    if (!rootId && this._nodes.length) rootId = this._nodes[0].data.id;

    // Build adjacency (directed)
    var adj = {};
    for (var i = 0; i < this._nodes.length; i++) {
      adj[this._nodes[i].data.id] = [];
    }
    for (var e = 0; e < this._edges.length; e++) {
      var ed = this._edges[e].data;
      if (adj[ed.source]) adj[ed.source].push(ed.target);
    }

    var level = {};
    var q = [];
    if (rootId && adj[rootId]) {
      level[rootId] = 0;
      q.push(rootId);
    }
    while (q.length) {
      var cur = q.shift();
      var nxt = adj[cur] || [];
      for (var j = 0; j < nxt.length; j++) {
        var to = nxt[j];
        if (level[to] === undefined) {
          level[to] = level[cur] + 1;
          q.push(to);
        }
      }
    }

    // Group nodes by level
    var groups = {};
    var maxL = 0;
    for (var k = 0; k < this._nodes.length; k++) {
      var id = this._nodes[k].data.id;
      var l = level[id];
      if (l === undefined) l = maxL + 1; // unreachable: push below
      if (l > maxL) maxL = l;
      if (!groups[l]) groups[l] = [];
      groups[l].push(this._nodes[k]);
    }

    var ySpacing = 130;
    var xSpacing = 150;
    Object.keys(groups).sort(function(a,b){ return Number(a)-Number(b); }).forEach(function(lk){
      var arr = groups[lk] || [];
      var lnum = Number(lk);
      for (var idx = 0; idx < arr.length; idx++) {
        arr[idx]._pos = { x: idx * xSpacing, y: lnum * ySpacing };
      }
    });
  };

  _Cytoscape.prototype._render = function () {
    var self = this;
    _clearNode(this._gEdges);
    _clearNode(this._gNodes);

    // Map node id -> position
    var pos = {};
    for (var i = 0; i < this._nodes.length; i++) {
      var nd = this._nodes[i];
      pos[nd.data.id] = nd._pos;
    }

    // Edges first
    for (var e = 0; e < this._edges.length; e++) {
      (function(edge){
        var d = edge.data;
        var sp = pos[d.source] || { x: 0, y: 0 };
        var tp = pos[d.target] || { x: 0, y: 0 };
        var line = _el('line');
        line.setAttribute('x1', sp.x);
        line.setAttribute('y1', sp.y);
        line.setAttribute('x2', tp.x);
        line.setAttribute('y2', tp.y);
        line.setAttribute('stroke', self._selectedEdgeId === d.id ? 'Highlight' : 'GrayText');
        line.setAttribute('stroke-width', self._selectedEdgeId === d.id ? '3' : '1');
        line.setAttribute('opacity', '0.85');
        line.style.cursor = 'pointer';
        line.addEventListener('click', function (evt) {
          evt.stopPropagation();
          self._selectedEdgeId = d.id;
          self._selectedNodeId = null;
          self._render();
          self._emit('select', new _Target('edge', d, self));
        });
        self._gEdges.appendChild(line);
      })(this._edges[e]);
    }

    // Nodes
    for (var n = 0; n < this._nodes.length; n++) {
      (function(node){
        var d = node.data;
        var p = node._pos || { x: 0, y: 0 };
        var g = _el('g');
        g.setAttribute('transform', 'translate(' + p.x + ',' + p.y + ')');
        g.style.cursor = 'pointer';

        var circle = _el('circle');
        circle.setAttribute('r', self._selectedNodeId === d.id ? '16' : '14');
        circle.setAttribute('cx', '0');
        circle.setAttribute('cy', '0');
        circle.setAttribute('fill', self._selectedNodeId === d.id ? 'Highlight' : 'ButtonFace');
        circle.setAttribute('stroke', (d.isCenter === 1 || d.isCenter === '1') ? 'Highlight' : 'GrayText');
        circle.setAttribute('stroke-width', (d.isCenter === 1 || d.isCenter === '1') ? '3' : '1');

        var label = _el('text');
        label.setAttribute('x', '20');
        label.setAttribute('y', '5');
        label.setAttribute('fill', 'CanvasText');
        label.setAttribute('font-size', '12');
        label.textContent = d.label || d.id;

        g.appendChild(circle);
        g.appendChild(label);

        g.addEventListener('click', function (evt) {
          evt.stopPropagation();
          self._selectedNodeId = d.id;
          self._selectedEdgeId = null;
          self._render();
          self._emit('select', new _Target('node', d, self));
        });

        self._gNodes.appendChild(g);
      })(this._nodes[n]);
    }

    this.fit(this.elements(), 60);
  };

  // Public factory
  window.cytoscape = function (opts) {
    return new _Cytoscape(opts);
  };
})();
